'''
오르막 수

오름차순으로 나열된 수를 길이 N으로 만들 수 있는 모든 경우를 출력
0부터 시작할 수 있음.

0일때 -> 9- 이전수 : 9
1일때 -> 9-이전수 : 8


이전수에 따라서 현재의 수가 달라지니까 2차원 배열로 만들어야할 것 같음

행 -> level(n길이)
열 -> 현재의 수가 0일때 / 1일때(이전수의 직전이 1보다 작거나 같은 경우를 모두 더함)/ 2일때(이전수의 마지막숫자가 2보다 작거나 같은 경우를 모두 더함)....9일때 
각 열이 의미하는 것이 그 길이를 만들때 그 열의 숫자가 k라면 k값을 만들수 있는 모든 경우의 수
'''

mod = 10007
n = int(input())

dp = [[0]*(10) for _ in range(n)]

for i in range(0,10):
    dp[0][i] = i+1

for i in range(1,n):
    for j in range(0,10):
        if j==0:
            dp[i][j] = (dp[i-1][j])%mod
        else:
            dp[i][j] = (dp[i][j-1] + dp[i-1][j])%mod
print((dp[n-1][9])%mod)






