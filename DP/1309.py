'''
3시 10분 시작

타일문제처럼 한 칸을 채울 수 있는 경우의 수는 3가지가 존재한다.

1. 아예 채우지 않는 경우 -> 이전 모든 경우가 더해짐
2. 오른쪽을 채우는 경우 -> 이전경우에서 왼쪽을 채우는 경우와 빈칸인 경우에만 가능함
3. 왼쪽을 채우는 경우 -> 이전경우에서 오른쪽을 채우는 경우와 빈칸을 채우는 경우가 가능함

이전 레벨에서 3가지를 나눠서 계속 고려해야하니까 2차원 배열을 사용해야한다.

level을 행으로 나타내고 0,1,2로(빈칸, 오른쪽, 왼쪽)으로 설정하여 고려한다.
각 레벨별로 가능한 위치를 넣어야함.

'''
mod = 9901
n = int(input())

dp = [[0]*(3) for _ in range(n)]

dp[0][0] = 1
dp[0][1] = 1
dp[0][2] = 1

for i in range(1,n):
    dp[i][0] = sum(dp[i-1])%mod
    dp[i][1] = (dp[i-1][0] + dp[i-1][2])%mod
    dp[i][2] = (dp[i-1][0] + dp[i-1][1])%mod

result = sum(dp[n-1])%mod
print(result)