# 최단경로 알고리즘

1. 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구하는 경우 -> 다익스트라 알고리즘
2. 한 지점에서 다른 특정 지점까지의 최단 경로를 구해야하는 경우 -> 플로이드 워셜 알고리즘

## 다익스트라 알고리즘

여러개의 노드가 있을 때, 특정한 노드에서 출발해서 다른 노드로 가는 각각의 최단 경로를 구해주는 알고리즘.</br>
음의 간선이 없을 때 정상적으로 작동 [ 현실에서처럼 0보다 작은 값을 가지는 간선이 없을 때 작동 ]

- 기본적으로 "가장 비용이 적은 노드"를 선택하는 과정을 반복하여, "그리디" 알고리즘

    1. 출발 노드를 설정
    2. 현재 노드에서 갈 수 있는 노드 사이의 최단 거리를 이용해 최단 거리 테이블 초기화
    3. 방문하지 않은 노드 중 최단 거리가 가장 짧은 노드를 선택
    4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신 </br>    

    <b> 한 번 선택된 노드는 최단거리가 감소하지 않음 </b>

- 시간 복잡도

    > O(V**2) : 노드의 개수 하나를 방문하고 단계마다 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택하기 위해서 1차원 리스트의 모든 원소를 순차 탐색


노드의 수가 10,000개를 넘어간다면 문제를 해결할 수 없음. 개선된 다익스트라 알고리즘을 이용한다.

## 개선된 다익스트라 알고리즘 

노드까지의 최단거리에 대한 정보를 힙에 담아서 출발 노드로부터 가장 짧은 거리의 노드를 더욱 빠르게 탐색한다. 이때 선형시간이 아닌 로그 시간이 걸린다. 노드의 수 1,000,000 이더라도 log2(N)이 약 20이다.

- 힙 자료구조</br>

    힙은 우선순위 queue를 구현하기 위해서 사용되는 자료구조 중 하나다.    
    > 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제한다. 데이터의 묶음을 넣으면 첫 번째 원소를 기준으로 우선순위를 설정하는 특징이 있다. (가치, 물건)의 경우 '가치'값이 우선순위를 결정하는 기준이 된다.
    
    python에서 PriorityQueue or heapq를 사용한다.
    > heapq가 더 빠르게 동작하기에 수행시간이 제한된 경우 heapq를 사용한다.

    우선순위 큐 구현시 최대 힙, 최소 힙 중에서 최단 경로 알고리즘에서는 최소 힙 구조가 적합하다.

- 시간 복잡도
    > 최악의 경우에도 O(ElogV)를 보장한다. V는 노드의 개수, E는 간선의 개수를 의미한다.

    간선의 최대 개수가 E라고 했을 때 우선순위 현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인하는 연산이 최대 E번 일어난다.


- 다익스트라와 우선순위 큐

    방문한 노드에서 튜플을 사용하여 (거리, 노드)를 heapq 라이브러리를 사용해 우선순위 큐에 넣는다.


## 플로이드 워셜 알고리즘

모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야하는 경우에 사용
매번 방문하지 않은 노두 중에서 최단 거리를 갖는 노드를 찾을 필요가 없음.

- 모든 노드에 대하여 최단 거리를 담아야 하기 때문에 2차원 리스트를 처리
- 플로이드 워셜 알고리즘은 다이나믹 프로그래밍이다.
    노드의 개수만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 DP로 봄.

- 노드를 차례대로 방문하면서 다른노드들 두개가 해당 노드를 거쳐가는 경우와 거치지 않고 가는 경우를 비교해서 작은 것을 선택한다. 

    > Dab = min(Dab, Dan + Dnb) : n(선택한 현재 노드)
    
    각 노드에서 나올 수 있는 경우를 체크하며 기존의 이차원 리스트값과 비교하여 가장 작은 결과를 이차원 리스트의 결과에 담아준다.

    이차원 리스트는 최단거리 정보를 표현하게 된다.

- 시간복잡도

    > N개의 노드 각각, 2차원 리스트를 처리해야해서 O(N^2) -> **O(N^3)** 이 된다.



